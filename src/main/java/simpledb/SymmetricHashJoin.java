package simpledb;

import java.util.*;

/**
 * The SymmetricHashJoin operator implements the symmetric hash join operation.
 */
public class SymmetricHashJoin extends Operator {
    private JoinPredicate pred;
    private DbIterator child1, child2;
    private TupleDesc comboTD;

    private HashMap<Object, ArrayList<Tuple>> leftMap = new HashMap<Object, ArrayList<Tuple>>();
    private HashMap<Object, ArrayList<Tuple>> rightMap = new HashMap<Object, ArrayList<Tuple>>();

    private DbIterator innerRelation;
    private DbIterator outerRelation;
    private State state;
    private boolean runOut = false;

    private class State{
        Iterator<Tuple> probePosition = null;
        Tuple currentTuple = null;
        boolean isSwitched = true;
        boolean isOnInner = true;
    }
     /**
     * Constructor. Accepts children to join and the predicate to join them on.
     * 
     * @param p
     *            The predicate to use to join the children
     * @param child1
     *            Iterator for the left(outer) relation to join
     * @param child2
     *            Iterator for the right(inner) relation to join
     */
    public SymmetricHashJoin(JoinPredicate p, DbIterator child1, DbIterator child2) {
        this.pred = p;
        this.child1 = child1;
        this.child2 = child2;
        innerRelation = child1;
        outerRelation = child2;
        state = new State();
        comboTD = TupleDesc.merge(child1.getTupleDesc(), child2.getTupleDesc());
    }

    public TupleDesc getTupleDesc() {
        return comboTD;
    }

    /**
     * Opens the iterator.
     */
    public void open() throws DbException, NoSuchElementException,
            TransactionAbortedException {
        // IMPLEMENT ME
        super.open();
        child1.open();
        child2.open();
    }

    /**
     * Closes the iterator.
     */
    public void close() {
        // IMPLEMENT ME
        child1.close();
        child2.close();
    }

    /**
     * Rewinds the iterator. You should not be calling this method for this join. 
     */
    public void rewind() throws DbException, TransactionAbortedException {
        child1.rewind();
        child2.rewind();
        this.leftMap.clear();
        this.rightMap.clear();
        String rewind = "rewind";
        System.out.println(rewind);
    }

    /**
     * Fetches the next tuple generated by the join, or null if there are no 
     * more tuples.  Logically, this is the next tuple in r1 cross r2 that
     * satifies the join predicate.
     *
     * Note that the tuples returned from this particular implementation are
     * simply the concatenation of joining tuples from the left and right
     * relation.  Therefore, there will be two copies of the join attribute in
     * the results.
     *
     * For example, joining {1,2,3} on equality of the first column with {1,5,6}
     * will return {1,2,3,1,5,6}.
     */
    protected Tuple fetchNext() throws TransactionAbortedException, DbException {
        // IMPLEMENT ME
        while (!runOut) {
            Iterator<Tuple> iter = state.probePosition;
            while (iter!=null && iter.hasNext()) {
                Tuple tuple = state.probePosition.next();
                if (pred.filter(tuple, state.currentTuple)) {
                    return state.isSwitched ?Tuple.merge(tuple,state.currentTuple)
                            :Tuple.merge(state.currentTuple,tuple);
                }
            }
            switchRelations();
        }
        return null;
    }

    /**
     * Switches the inner and outer relation.
     */
    int i = 0;
    private void switchRelations() throws TransactionAbortedException, DbException {
        if (!innerRelation.hasNext() && !outerRelation.hasNext()){
            runOut = true;
            return;
        }else if (!innerRelation.hasNext() && outerRelation.hasNext()){
            state.isSwitched = true;
            state.currentTuple = outerRelation.next();
            Field field = state.currentTuple.getField(pred.getField2());
            insertTuple(rightMap, state.currentTuple, field);
            System.out.println(state.currentTuple.toString());

            ArrayList<Tuple> bucket = leftMap.get(field);
            state.probePosition = bucket != null? bucket.iterator() : null;
            return;
        } else if (!outerRelation.hasNext() && innerRelation.hasNext()) {
           state.isSwitched = false;
            state.currentTuple = innerRelation.next();
            Field field = state.currentTuple.getField(pred.getField1());

            //System.out.println(state.currentTuple.toString());
            insertTuple(leftMap, state.currentTuple, field);
            System.out.println(state.currentTuple.toString());

            ArrayList<Tuple> bucket = rightMap.get(field);
            state.probePosition = bucket != null ? bucket.iterator() : null;
            return;
        }

        if (state.isSwitched) {
            System.out.println(i++);
            state.isSwitched = false;
            state.currentTuple = innerRelation.next();
            Field field = state.currentTuple.getField(pred.getField1());

            insertTuple(leftMap, state.currentTuple, field);
            System.out.println(state.currentTuple.toString());

            ArrayList<Tuple> bucket = rightMap.get(field);
            state.probePosition = bucket != null ? bucket.iterator() : null;
        } else {
            state.isSwitched = true;
            state.currentTuple = outerRelation.next();
            Field field = state.currentTuple.getField(pred.getField2());
            insertTuple(rightMap, state.currentTuple, field);
            System.out.println(state.currentTuple.toString());
            ArrayList<Tuple> bucket = leftMap.get(field);
            state.probePosition = bucket != null? bucket.iterator() : null;
        }
        // IMPLEMENT ME
    }
    private void switchRelations2() throws TransactionAbortedException, DbException {
        if (innerRelation.hasNext() && outerRelation.hasNext()) {

        }

        if (state.isSwitched) {
            System.out.println(i++);
            state.isSwitched = false;
            state.currentTuple = innerRelation.next();
            Field field = state.currentTuple.getField(pred.getField1());

            System.out.println(state.currentTuple.toString());
            insertTuple(leftMap, state.currentTuple, field);
            System.out.println(state.currentTuple.toString());

            ArrayList<Tuple> bucket = rightMap.get(field);
            state.probePosition = bucket != null ? bucket.iterator() : null;
        } else if (!state.isSwitched && outerRelation.hasNext()){
            state.isSwitched = true;
            state.currentTuple = outerRelation.next();
           // System.out.println(state.currentTuple.toString());
            Field field = state.currentTuple.getField(pred.getField2());
            insertTuple(rightMap, state.currentTuple, field);
            ArrayList<Tuple> bucket = leftMap.get(field);
            state.probePosition = bucket != null? bucket.iterator() : null;
        }
        // IMPLEMENT ME
    }

private void insertTuple(HashMap<Object, ArrayList<Tuple>> map, Tuple tuple, Field field) {

    ArrayList<Tuple> tuples = map.get(field);
    if (tuples != null) {
        tuples.add(tuple);
    } else {
        tuples = new ArrayList<>();
        tuples.add(tuple);
        map.put(field, tuples);
    }


}
    @Override
    public DbIterator[] getChildren() {
        return new DbIterator[]{this.child1, this.child2};
    }

    @Override
    public void setChildren(DbIterator[] children) {
        this.child1 = children[0];
        this.child2 = children[1];
    }

}